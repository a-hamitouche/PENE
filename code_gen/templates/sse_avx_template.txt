
#pragma once
#include <pin.H>
extern "C"
{
# include <xed-decoded-inst-api.h>
}


namespace pene 
{
  namespace replace
  {
    namespace wrappers
    {
      namespace {{architecture_name}}
      {
        
        template<typename T, void (*backend_fct)(T, T, T*,void*)>
        void PIN_FAST_ANALYSIS_CALL call_backend_fct(T* const a, T* const b, T* c,void* ctx)
        {
          OutFile << "Reached function call_backend_fct" << std::endl;
          backend_fct(*a,*b,c,ctx);
        }

        template<typename T>
        void PIN_FAST_ANALYSIS_CALL copy_from_input(T* src,T* dst,int i)
        {
          OutFile << "Reached function copy from input" << std::endl;
          (*dst)=(src)[i];
        }

        template<typename T>
        void PIN_FAST_ANALYSIS_CALL copy_to_output(T* src,T* dst,int i)
        {
          OutFile << "Reached function copy from output" << std::endl;
          dst[i]=(*src);
        }

        template <typename OPERATION_IMPL>
        void instrument(void* backend_ctx, INS ins,REG tmp_reg1, REG tmp_reg2, REG tmp_reg_output)
        {
          auto xed = INS_XedDec(ins); // TODO check that pointer does not need to be freed
          auto iform = xed_decoded_inst_get_iform_enum(xed);
          switch (iform)

          {   
            {% for instruction in instructions %}
              {% if instruction.ins_isa == 'sse' %}
                {% set offset=0 %}
              {%- elif instruction.ins_isa == 'avx' %}
                {% set offset=1 %}
              {%- elif  instruction.ins_isa == 'avx512' %}
                {% set offset=2 %}   
              {% endif %}
              case xed_iform_enum_t::{{instruction.token}}:
              OutFile << "Found one {{instruction.token}} " << std::endl;
              {% if instruction.simd_option == 'scalar' %}
                INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)call_backend_fct<{{instruction.ins_precision.associated_type}},OPERATION_IMPL::{{instruction.op_type}}_{{instruction.ins_precision.associated_type}}>,
                IARG_FAST_ANALYSIS_CALL,
                {% for eff_operand in instruction.eff_operands %}
                {%+ if eff_operand.kind == 'reg' %}IARG_REG_CONST_REFERENCE, INS_OperandReg(ins, {{eff_operand.index}}){%+ elif  eff_operand.kind == 'mem' %}IARG_MEMORYREAD_EA{% endif %},
                {% endfor %}
                {%+ if instruction.operands[0].kind == 'reg' %}IARG_REG_REFERENCE, INS_OperandReg(ins, 0){% elif  instruction.operands[0].kind == 'mem' %}IARG_MEMORYREAD_EA{% endif %},
                IARG_PTR, backend_ctx,
                IARG_END);
             {% elif instruction.simd_option == 'packed' %}
                for(int i=0 ; i<{{instruction.nb_elements}} ; i++)
                  {
                  INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)copy_from_input<{{instruction.ins_precision.associated_type}}>,
                  IARG_FAST_ANALYSIS_CALL,
                  {%+ if instruction.operands[offset].kind== 'reg' %}IARG_REG_CONST_REFERENCE, INS_OperandReg(ins,{{offset}}){%+ elif  instruction.operands[offset].kind== 'mem' %}IARG_MEMORYREAD_EA{% endif %},
                  IARG_REG_REFERENCE, tmp_reg1,
                  IARG_UINT32 ,i,
                  IARG_END);
                  INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)copy_from_input<{{instruction.ins_precision.associated_type}}>,
                  IARG_FAST_ANALYSIS_CALL,
                  {%+ if instruction.operands[offset+1].kind== 'reg' %}IARG_REG_CONST_REFERENCE, INS_OperandReg(ins,{{offset+1}}){%+ elif  instruction.operands[offset+1].kind== 'mem' %}IARG_MEMORYREAD_EA{% endif %},
                  IARG_REG_REFERENCE, tmp_reg2,
                  IARG_UINT32,i,
                  IARG_END);
                  INS_InsertCall(ins, IPOINT_BEFORE,(AFUNPTR)call_backend_fct<{{instruction.ins_precision.associated_type}},OPERATION_IMPL::{{instruction.op_type}}_{{instruction.ins_precision.associated_type}}>,
                  IARG_FAST_ANALYSIS_CALL,
                  IARG_REG_CONST_REFERENCE, tmp_reg1,
                  IARG_REG_CONST_REFERENCE, tmp_reg2,
                  IARG_REG_REFERENCE, tmp_reg_output,
                  IARG_PTR, backend_ctx,
                  IARG_END);
                  INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)copy_to_output<{{instruction.ins_precision.associated_type}}>,
                  IARG_FAST_ANALYSIS_CALL,
                  IARG_REG_CONST_REFERENCE,tmp_reg_output,
                  IARG_REG_REFERENCE,INS_OperandReg(ins,0),
                  IARG_UINT32 ,i,
                  IARG_END);
                 }
              {% endif %}
                  INS_Delete(ins);
                  OutFile << "Reached end of {{instruction.token}}" << std::endl;
                  break;
            {% endfor %}
            default:
              return;

                  
          }
        }


      }
    }
  }
}
