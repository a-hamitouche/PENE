
{%- macro first_op_number(isa) -%}
  {%- if isa == 'sse' -%}0
  {%- elif isa == 'avx' -%}1
  {%- endif -%}
{% endmacro %}

{%- macro second_op_number(isa) -%}
  {%- if isa == 'sse' -%}1
  {%- elif isa == 'avx' -%}2
  {%- endif -%}
{%- endmacro -%}

#pragma once
#include <pin.H>
extern "C"
{
# include <xed-decoded-inst-api.h>
}


namespace pene 
{
  namespace replace
  {
    namespace wrappers
    {
      namespace {{architecture_name}}
      {
        
        template<typename T, void (*backend_fct)(T, T, T*,void*)>
        void PIN_FAST_ANALYSIS_CALL call_backend_fct(T* const a, T* const b, T* c,void* ctx)
        {
          OutFile << "Reached function call_backend_fct" << std::endl;
          backend_fct(*a,*b,c,ctx);
        }

        template<typename T>
        void PIN_FAST_ANALYSIS_CALL copy_from_input(T* src,T* dst,int i)
        {
          OutFile << "Reached function copy from input" << std::endl;
          (*dst)=(src)[i];
        }

        template<typename T>
        void PIN_FAST_ANALYSIS_CALL copy_to_output(T* src,T* dst,int i)
        {
          OutFile << "Reached function copy from output" << std::endl;
          dst[i]=(*src);
        }

        template <typename OPERATION_IMPL>
        void instrument(void* backend_ctx, INS ins,REG tmp_reg1, REG tmp_reg2, REG tmp_reg_output)
        {
          auto xed = INS_XedDec(ins); // TODO check that pointer does not need to be freed
          auto iform = xed_decoded_inst_get_iform_enum(xed);
          switch (iform)

          {   
            {% for instruction in instructions %}
              case xed_iform_enum_t::{{instruction.token}}:
              OutFile << "Found one {{instruction.token}} " << std::endl;
              {% if instruction.simd_option == 'scalar' %}
                INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)call_backend_fct<{{instruction.ins_precision.associated_type}},OPERATION_IMPL::{{instruction.op_type}}_{{instruction.ins_precision.associated_type}}>,
                IARG_FAST_ANALYSIS_CALL,
                {% for eff_operand in instruction.eff_operands %}
                {%+ if eff_operand.kind == 'reg' %}IARG_REG_CONST_REFERENCE, INS_OperandReg(ins, {{eff_operand.index}}){%+ elif  eff_operand.kind == 'mem' %}IARG_MEMORYREAD_EA{% endif %},
                {% endfor %}
                {%+ if instruction.operands[0].kind == 'reg' %}IARG_REG_REFERENCE, INS_OperandReg(ins, 0){% elif  instruction.operands[0].kind == 'mem' %}IARG_MEMORYREAD_EA{% endif %},
                IARG_PTR, backend_ctx,
                IARG_END);
             {% elif instruction.simd_option == 'packed' %}
                for(int i=0 ; i<{{instruction.nb_elements}} ; i++)
                  {
                  INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)copy_from_input<{{instruction.ins_precision.associated_type}}>,
                  IARG_FAST_ANALYSIS_CALL,
                  {%+ if instruction.kind1== 'reg' %}IARG_REG_CONST_REFERENCE, INS_OperandReg(ins,{{instruction.index1}}){%+ elif  instruction.kind1== 'mem' %}IARG_MEMORYREAD_EA{% endif %},
                  IARG_REG_REFERENCE, tmp_reg1,
                  IARG_UINT32 ,i,
                  IARG_END);
                  INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)copy_from_input<{{instruction.ins_precision.associated_type}}>,
                  IARG_FAST_ANALYSIS_CALL,
                  {%+ if instruction.kind2== 'reg' %}IARG_REG_CONST_REFERENCE, INS_OperandReg(ins,{{instruction.index2}}){%+ elif  instruction.kind2== 'mem' %}IARG_MEMORYREAD_EA{% endif %},
                  IARG_REG_REFERENCE, tmp_reg2,
                  IARG_UINT32,i,
                  IARG_END);
                  INS_InsertCall(ins, IPOINT_BEFORE,(AFUNPTR)call_backend_fct<{{instruction.ins_precision.associated_type}},OPERATION_IMPL::{{instruction.op_type}}_{{instruction.ins_precision.associated_type}}>,
                  IARG_FAST_ANALYSIS_CALL,
                  IARG_REG_CONST_REFERENCE, tmp_reg1,
                  IARG_REG_CONST_REFERENCE, tmp_reg2,
                  IARG_REG_REFERENCE, tmp_reg_output,
                  IARG_PTR, backend_ctx,
                  IARG_END);
                  INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)copy_to_output<{{instruction.ins_precision.associated_type}}>,
                  IARG_FAST_ANALYSIS_CALL,
                  IARG_REG_CONST_REFERENCE,tmp_reg_output,
                  IARG_REG_REFERENCE,INS_OperandReg(ins,0),
                  IARG_UINT32 ,i,
                  IARG_END);
                 }
              {% endif %}
                  INS_Delete(ins);
                  OutFile << "Reached end of {{instruction.token}}" << std::endl;
                  break;
            {% endfor %}
            default:
              return;

                  
          }
        }


      }
    }
  }
}
